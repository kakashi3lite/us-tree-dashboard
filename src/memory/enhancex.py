"""\nEnhanceX Integration Module\n\nProvides integration between the memory management system and the dashboard application.\nThis module serves as the main entry point for using EnhanceX features.\n"""\n\nimport os\nimport logging\nfrom typing import Dict, Any, Optional, List, Union, Callable\nimport time\nimport json\nfrom pathlib import Path\n\nfrom .memory_store import MemoryStore, MemoryType\nfrom .context_manager import ContextManager\nfrom .preference_tracker import PreferenceTracker\nfrom .session_memory import SessionMemory\n\nlogger = logging.getLogger(__name__)\n\nclass EnhanceX:\n    """\n    Main integration class for EnhanceX features.\n    \n    Provides a unified interface for all memory management capabilities:\n    - Session memory for tracking user interactions\n    - User preferences for personalization\n    - Project context for maintaining project state\n    - Memory persistence for long-term storage\n    """\n    \n    def __init__(self, data_dir: Optional[str] = None, session_timeout: int = 30):\n        """\n        Initialize EnhanceX integration.\n        \n        Args:\n            data_dir: Directory for storing persistent data\n                     (defaults to 'data/memory' in the project root)\n            session_timeout: Session timeout in minutes\n        """\n        # Set up data directory\n        if data_dir is None:\n            # Default to data/memory in the project root\n            project_root = Path(__file__).parent.parent.parent\n            data_dir = os.path.join(project_root, 'data', 'memory')\n        \n        # Ensure data directory exists\n        os.makedirs(data_dir, exist_ok=True)\n        \n        # Initialize components\n        self.memory_store = MemoryStore(data_dir)\n        self.context_manager = ContextManager(self.memory_store)\n        self.preference_tracker = PreferenceTracker(self.memory_store)\n        self.session_memory = SessionMemory(self.memory_store, session_timeout)\n        \n        # Initialize default preferences if needed\n        if not self.preference_tracker.has_preferences():\n            self._initialize_default_preferences()\n        \n        logger.info(f"EnhanceX initialized with data directory: {data_dir}")\n    \n    def _initialize_default_preferences(self):\n        """Initialize default user preferences."""\n        # UI preferences\n        self.preference_tracker.create_category(\n            "ui", "UI Preferences", "User interface display preferences"\n        )\n        self.preference_tracker.set_preference("ui", "theme", "light")\n        self.preference_tracker.set_preference("ui", "sidebar_collapsed", False)\n        self.preference_tracker.set_preference("ui", "map_style", "streets")\n        \n        # Data visualization preferences\n        self.preference_tracker.create_category(\n            "visualization", "Visualization Preferences", "Chart and graph display preferences"\n        )\n        self.preference_tracker.set_preference("visualization", "default_chart_type", "bar")\n        self.preference_tracker.set_preference("visualization", "color_palette", "viridis")\n        self.preference_tracker.set_preference("visualization", "show_grid_lines", True)\n        \n        # Notification preferences\n        self.preference_tracker.create_category(\n            "notifications", "Notification Preferences", "User notification settings"\n        )\n        self.preference_tracker.set_preference("notifications", "show_alerts", True)\n        self.preference_tracker.set_preference("notifications", "notification_position", "top-right")\n        \n        logger.info("Default preferences initialized")\n    \n    def start_session(self, metadata: Optional[Dict[str, Any]] = None) -> str:\n        """\n        Start a new user session.\n        \n        Args:\n            metadata: Optional metadata about the session\n            \n        Returns:\n            Session ID\n        """\n        return self.session_memory.start_session(metadata)\n    \n    def end_session(self) -> bool:\n        """End the current user session."""\n        return self.session_memory.end_session()\n    \n    def record_interaction(self, interaction_type: str, data: Dict[str, Any], \n                         metadata: Optional[Dict[str, Any]] = None) -> Optional[str]:\n        """\n        Record a user interaction.\n        \n        Args:\n            interaction_type: Type of interaction (e.g., 'filter_change', 'chart_click')\n            data: Interaction data\n            metadata: Optional metadata\n            \n        Returns:\n            Interaction ID or None if no active session\n        """\n        return self.session_memory.record_interaction(interaction_type, data, metadata)\n    \n    def get_user_preference(self, category: str, key: str, default: Any = None) -> Any:\n        """\n        Get a user preference.\n        \n        Args:\n            category: Preference category\n            key: Preference key\n            default: Default value if preference not found\n            \n        Returns:\n            Preference value or default\n        """\n        value = self.preference_tracker.get_preference(category, key)\n        return default if value is None else value\n    \n    def set_user_preference(self, category: str, key: str, value: Any) -> bool:\n        """\n        Set a user preference.\n        \n        Args:\n            category: Preference category\n            key: Preference key\n            value: Preference value\n            \n        Returns:\n            Success status\n        """\n        return self.preference_tracker.set_preference(category, key, value)\n    \n    def get_all_preferences(self) -> Dict[str, Dict[str, Any]]:\n        """Get all user preferences."""\n        return self.preference_tracker.get_all_preferences()\n    \n    def create_project_context(self, name: str, description: str = "", \n                             data: Optional[Dict[str, Any]] = None) -> str:\n        """\n        Create a new project context.\n        \n        Args:\n            name: Context name\n            description: Context description\n            data: Initial context data\n            \n        Returns:\n            Context ID\n        """\n        return self.context_manager.create_context(name, description, data)\n    \n    def get_project_context(self, context_id: str) -> Optional[Dict[str, Any]]:\n        """\n        Get a project context.\n        \n        Args:\n            context_id: Context ID\n            \n        Returns:\n            Context data or None if not found\n        """\n        context = self.context_manager.get_context(context_id)\n        return context.data if context else None\n    \n    def update_project_context(self, context_id: str, updates: Dict[str, Any]) -> bool:\n        """\n        Update a project context.\n        \n        Args:\n            context_id: Context ID\n            updates: Data updates\n            \n        Returns:\n            Success status\n        """\n        return self.context_manager.update_context(context_id, updates)\n    \n    def get_session_state(self, key: Optional[str] = None) -> Any:\n        """\n        Get current session state.\n        \n        Args:\n            key: Optional specific state key\n            \n        Returns:\n            State value or entire state dict\n        """\n        return self.session_memory.get_state(key)\n    \n    def update_session_state(self, updates: Dict[str, Any]) -> bool:\n        """\n        Update session state.\n        \n        Args:\n            updates: State updates\n            \n        Returns:\n            Success status\n        """\n        return self.session_memory.update_state(updates)\n    \n    def get_recent_interactions(self, interaction_type: Optional[str] = None, \n                              limit: int = 10) -> List[Dict[str, Any]]:\n        """\n        Get recent user interactions.\n        \n        Args:\n            interaction_type: Optional filter by interaction type\n            limit: Maximum number of interactions to return\n            \n        Returns:\n            List of recent interactions\n        """\n        return self.session_memory.get_recent_interactions(interaction_type, limit)\n    \n    def register_interaction_handler(self, interaction_type: str, handler: Callable) -> None:\n        """\n        Register a handler for a specific interaction type.\n        \n        Args:\n            interaction_type: Type of interaction to handle\n            handler: Callback function that takes an Interaction object\n        """\n        self.session_memory.register_interaction_handler(interaction_type, handler)\n    \n    def is_session_active(self) -> bool:\n        """Check if there is an active user session."""\n        return self.session_memory.is_session_active()\n    \n    def keep_session_alive(self) -> bool:\n        """Update last activity time to keep session alive."""\n        return self.session_memory.keep_alive()\n    \n    def get_session_duration(self) -> Optional[float]:\n        """Get current session duration in seconds."""\n        return self.session_memory.get_session_duration()\n    \n    def store_long_term_memory(self, key: str, value: Any, \n                             expiry: Optional[float] = None) -> bool:\n        """\n        Store a value in long-term memory.\n        \n        Args:\n            key: Memory key\n            value: Value to store\n            expiry: Optional expiry timestamp\n            \n        Returns:\n            Success status\n        """\n        return self.memory_store.store(key, value, MemoryType.LONG_TERM, expiry)\n    \n    def retrieve_long_term_memory(self, key: str) -> Any:\n        """\n        Retrieve a value from long-term memory.\n        \n        Args:\n            key: Memory key\n            \n        Returns:\n            Stored value or None if not found\n        """\n        return self.memory_store.retrieve(key, MemoryType.LONG_TERM)\n    \n    def cleanup_expired_memory(self) -> int:\n        """\n        Clean up expired memory entries.\n        \n        Returns:\n            Number of entries cleaned up\n        """\n        return self.memory_store.cleanup_expired()