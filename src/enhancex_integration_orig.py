"""\nEnhanceX Integration Module for Dashboard\n\nThis module provides integration between the EnhanceX memory management system\nand the main dashboard application.\n"""\n\nimport os\nimport logging\nfrom typing import Dict, Any, Optional, List, Union, Callable\nimport time\nimport json\nfrom functools import wraps\n\nfrom dash import Dash, callback_context\nfrom dash.dependencies import Input, Output, State, ClientsideFunction\nimport dash_bootstrap_components as dbc\nimport dash_html_components as html\nimport dash_core_components as dcc\n\nfrom .memory import EnhanceX\nfrom .enhanced_monitor import EnhancedDashboardMonitor\n\nlogger = logging.getLogger(__name__)\n\n# Initialize EnhanceX\nenhancex = EnhanceX()\n\n# Store for active sessions\nactive_sessions = {}\n\ndef initialize_enhancex(app: Dash):\n    """\n    Initialize EnhanceX integration with the Dash app.\n    \n    Args:\n        app: Dash application instance\n    """\n    # Create hidden div for storing session info\n    app.layout.children.append(\n        html.Div(id='enhancex-session-store', style={'display': 'none'})\n    )\n    \n    # Create hidden div for storing user preferences\n    app.layout.children.append(\n        html.Div(id='enhancex-preferences-store', style={'display': 'none'})\n    )\n    \n    # Create hidden div for interaction tracking\n    app.layout.children.append(\n        html.Div(id='enhancex-interaction-tracker', style={'display': 'none'})\n    )\n    \n    # Initialize session on page load\n    @app.callback(\n        Output('enhancex-session-store', 'children'),\n        Input('url', 'pathname'),\n        prevent_initial_call=True\n    )\n    def initialize_session(pathname):\n        # Get client info from callback context if available\n        client_info = {}\n        \n        # Start a new session\n        session_id = enhancex.start_session(client_info)\n        active_sessions[session_id] = time.time()\n        \n        # Store session ID in hidden div\n        return json.dumps({'session_id': session_id})\n    \n    # Load user preferences\n    @app.callback(\n        Output('enhancex-preferences-store', 'children'),\n        Input('enhancex-session-store', 'children')\n    )\n    def load_preferences(session_data):\n        if not session_data:\n            return '{}'\n        \n        # Get all user preferences\n        preferences = enhancex.get_all_preferences()\n        return json.dumps(preferences)\n    \n    # Keep session alive with periodic pings\n    app.clientside_callback(\n        ClientsideFunction(\n            namespace='enhancex',\n            function_name='keepSessionAlive'\n        ),\n        Output('enhancex-session-store', 'data-last-ping'),\n        Input('enhancex-session-store', 'children'),\n        Input('interval-component', 'n_intervals')\n    )\n    \n    # Add client-side JavaScript for session management\n    app.index_string = app.index_string.replace(\n        '</head>',\n        '''
        <script>\n        window.dash_clientside = Object.assign({}, window.dash_clientside, {\n            enhancex: {\n                keepSessionAlive: function(sessionData, n_intervals) {\n                    if (sessionData) {\n                        // Send ping every minute\n                        fetch('/enhancex/ping', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json',\n                            },\n                            body: sessionData\n                        });\n                        return Date.now();\n                    }\n                    return null;\n                }\n            }\n        });\n        </script>\n        </head>'''\n    )\n    \n    # Add interval component for periodic updates\n    if not any(isinstance(child, dcc.Interval) and child.id == 'interval-component' \n               for child in app.layout.children):\n        app.layout.children.append(\n            dcc.Interval(\n                id='interval-component',\n                interval=60000,  # 1 minute in milliseconds\n                n_intervals=0\n            )\n        )\n    \n    # Add route for session ping\n    @app.server.route('/enhancex/ping', methods=['POST'])\n    def ping_session():\n        from flask import request, jsonify\n        \n        try:\n            data = request.get_json()\n            session_id = data.get('session_id')\n            \n            if session_id and enhancex.is_session_active():\n                enhancex.keep_session_alive()\n                active_sessions[session_id] = time.time()\n                return jsonify({'status': 'success'})\n            \n            return jsonify({'status': 'error', 'message': 'Invalid session'})\n        \n        except Exception as e:\n            logger.error(f"Error in ping_session: {e}")\n            return jsonify({'status': 'error', 'message': str(e)})\n    \n    logger.info("EnhanceX integration initialized")\n\ndef track_interaction(interaction_type: str):\n    """\n    Decorator for tracking user interactions.\n    \n    Args:\n        interaction_type: Type of interaction to track\n    """\n    def decorator(callback_func):\n        @wraps(callback_func)\n        def wrapper(*args, **kwargs):\n            # Get session ID from callback context if available\n            ctx = callback_context\n            session_id = None\n            \n            if ctx.inputs and 'enhancex-session-store.children' in ctx.inputs:\n                try:\n                    session_data = json.loads(ctx.inputs['enhancex-session-store.children'])\n                    session_id = session_data.get('session_id')\n                except (json.JSONDecodeError, TypeError):\n                    pass\n            \n            # Get triggered input\n            triggered = ctx.triggered[0] if ctx.triggered else None\n            trigger_id = triggered['prop_id'].split('.')[0] if triggered else None\n            trigger_value = triggered['value'] if triggered else None\n            \n            # Record interaction if session is active\n            if session_id and enhancex.is_session_active():\n                interaction_data = {\n                    'trigger_id': trigger_id,\n                    'trigger_value': trigger_value,\n                    'timestamp': time.time()\n                }\n                \n                enhancex.record_interaction(interaction_type, interaction_data)\n            \n            # Call the original callback function\n            return callback_func(*args, **kwargs)\n        \n        return wrapper\n    \n    return decorator\n\ndef apply_user_preferences(app: Dash):\n    """\n    Apply user preferences to the dashboard.\n    \n    Args:\n        app: Dash application instance\n    """\n    # Apply theme preference\n    @app.callback(\n        Output('app-container', 'className'),\n        Input('enhancex-preferences-store', 'children')\n    )\n    def update_theme(preferences_json):\n        try:\n            preferences = json.loads(preferences_json) if preferences_json else {}\n            ui_prefs = preferences.get('ui', {})\n            theme = ui_prefs.get('theme', 'light')\n            \n            return f"app-container theme-{theme}"\n        \n        except (json.JSONDecodeError, TypeError):\n            return "app-container theme-light"\n    \n    # Apply visualization preferences\n    @app.callback(\n        Output('visualization-container', 'data-preferences'),\n        Input('enhancex-preferences-store', 'children')\n    )\n    def update_visualization_preferences(preferences_json):\n        try:\n            preferences = json.loads(preferences_json) if preferences_json else {}\n            viz_prefs = preferences.get('visualization', {})\n            \n            return json.dumps(viz_prefs)\n        \n        except (json.JSONDecodeError, TypeError):\n            return '{}'\n\ndef integrate_with_monitor(monitor: EnhancedDashboardMonitor):\n    """\n    Integrate EnhanceX with the dashboard monitor.\n    \n    Args:\n        monitor: Dashboard monitor instance\n    """\n    # Register interaction handler for page views\n    def handle_page_view(interaction):\n        monitor.start_request_logging(\n            request_id=interaction.interaction_id,\n            request_type="page_view",\n            metadata=interaction.metadata\n        )\n        \n        # End request after a short delay (simulating page load)\n        def end_request():\n            monitor.end_request_logging(interaction.interaction_id)\n        \n        # Schedule end_request to run after 100ms\n        from threading import Timer\n        Timer(0.1, end_request).start()\n    \n    enhancex.register_interaction_handler("page_view", handle_page_view)\n    \n    # Register interaction handler for data loading\n    def handle_data_load(interaction):\n        monitor.track_component_timing(\n            request_id=interaction.interaction_id,\n            component_name=interaction.data.get('component', 'unknown'),\n            duration=interaction.data.get('duration', 0)\n        )\n    \n    enhancex.register_interaction_handler("data_load", handle_data_load)\n    \n    # Register interaction handler for cache events\n    def handle_cache_event(interaction):\n        if interaction.data.get('hit', False):\n            monitor.track_cache_hit()\n        else:\n            monitor.track_cache_miss()\n    \n    enhancex.register_interaction_handler("cache_event", handle_cache_event)\n\ndef cleanup_sessions():\n    """Cleanup expired sessions."""\n    current_time = time.time()\n    expired_sessions = []\n    \n    for session_id, last_activity in active_sessions.items():\n        # Check if session has been inactive for more than 30 minutes\n        if current_time - last_activity > 1800:  # 30 minutes in seconds\n            expired_sessions.append(session_id)\n    \n    # Remove expired sessions\n    for session_id in expired_sessions:\n        del active_sessions[session_id]\n    \n    # Cleanup expired memory entries\n    enhancex.cleanup_expired_memory()\n    \n    logger.info(f"Cleaned up {len(expired_sessions)} expired sessions")