"""\nNotification System Component for EnhanceX\n\nProvides a notification system that leverages EnhanceX's session memory\nto track and display notifications to users.\n"""\n\nimport json\nimport uuid\nfrom datetime import datetime\n\nimport dash\nfrom dash import html, dcc, Input, Output, State, callback_context\nimport dash_bootstrap_components as dbc\n\nfrom ..memory import EnhanceX\n\n# Initialize EnhanceX\nenhancex = EnhanceX()\n\n# Notification types\nNOTIFICATION_TYPES = {\n    "info": {"icon": "info-circle", "color": "info"},\n    "success": {"icon": "check-circle", "color": "success"},\n    "warning": {"icon": "exclamation-triangle", "color": "warning"},\n    "error": {"icon": "exclamation-circle", "color": "danger"}\n}\n\n# Default notification duration in milliseconds\nDEFAULT_DURATION = 5000\n\ndef create_notification_system():\n    """Create a notification system component."""\n    return html.Div(\n        id="notification-system",\n        className="notification-system",\n        children=[\n            # Notification container\n            html.Div(\n                id="notification-container",\n                className="notification-container"\n            ),\n            \n            # Notification history button\n            html.Div(\n                className="notification-history-button-container",\n                children=[\n                    dbc.Button(\n                        html.I(className="fas fa-bell"),\n                        id="notification-history-button",\n                        color="light",\n                        className="rounded-circle",\n                        size="sm"\n                    ),\n                    html.Span(\n                        id="notification-badge",\n                        className="notification-badge d-none"\n                    )\n                ]\n            ),\n            \n            # Notification history modal\n            dbc.Modal(\n                [\n                    dbc.ModalHeader("Notification History"),\n                    dbc.ModalBody(\n                        html.Div(\n                            id="notification-history-container",\n                            className="notification-history-container"\n                        )\n                    ),\n                    dbc.ModalFooter(\n                        dbc.Button(\n                            "Close",\n                            id="close-notification-history",\n                            className="ms-auto",\n                            n_clicks=0\n                        )\n                    ),\n                ],\n                id="notification-history-modal",\n                is_open=False,\n                centered=True,\n                size="lg"\n            ),\n            \n            # Store for notifications\n            dcc.Store(id="notification-store", data={\n                "notifications": [],\n                "unread_count": 0\n            }),\n            \n            # Interval for checking new notifications\n            dcc.Interval(\n                id="notification-interval",\n                interval=5 * 1000,  # 5 seconds\n                n_intervals=0\n            )\n        ]\n    )\n\ndef create_notification(notification_type, message, title=None, duration=DEFAULT_DURATION):\n    """\n    Create a notification object.\n    \n    Args:\n        notification_type (str): Type of notification (info, success, warning, error)\n        message (str): Notification message\n        title (str, optional): Notification title\n        duration (int, optional): Duration in milliseconds\n        \n    Returns:\n        dict: Notification object\n    """\n    if notification_type not in NOTIFICATION_TYPES:\n        notification_type = "info"\n        \n    notification_id = str(uuid.uuid4())\n    timestamp = datetime.now().isoformat()\n    \n    return {\n        "id": notification_id,\n        "type": notification_type,\n        "message": message,\n        "title": title,\n        "timestamp": timestamp,\n        "duration": duration,\n        "read": False\n    }\n\ndef render_notification(notification):\n    """\n    Render a notification as a Dash component.\n    \n    Args:\n        notification (dict): Notification object\n        \n    Returns:\n        dash.html.Div: Notification component\n    """\n    notification_type = notification.get("type", "info")\n    notification_info = NOTIFICATION_TYPES.get(notification_type, NOTIFICATION_TYPES["info"])\n    \n    icon = notification_info["icon"]\n    color = notification_info["color"]\n    \n    header = []\n    if notification.get("title"):\n        header.append(html.Strong(notification["title"], className="me-auto"))\n    \n    timestamp = datetime.fromisoformat(notification["timestamp"])\n    formatted_time = timestamp.strftime("%H:%M:%S")\n    header.append(html.Small(formatted_time, className="text-muted"))\n    \n    return dbc.Toast(\n        [\n            html.P(notification["message"], className="mb-0")\n        ],\n        id={"type": "notification-toast", "index": notification["id"]},\n        header=header,\n        icon=html.I(className=f"fas fa-{icon}"),\n        dismissable=True,\n        is_open=True,\n        duration=notification.get("duration", DEFAULT_DURATION),\n        color=color,\n        className="notification-toast"\n    )\n\ndef render_notification_history_item(notification):\n    """\n    Render a notification history item.\n    \n    Args:\n        notification (dict): Notification object\n        \n    Returns:\n        dash.html.Div: Notification history item component\n    """\n    notification_type = notification.get("type", "info")\n    notification_info = NOTIFICATION_TYPES.get(notification_type, NOTIFICATION_TYPES["info"])\n    \n    icon = notification_info["icon"]\n    color = notification_info["color"]\n    \n    timestamp = datetime.fromisoformat(notification["timestamp"])\n    formatted_date = timestamp.strftime("%Y-%m-%d %H:%M:%S")\n    \n    return html.Div(\n        className=f"notification-history-item {'' if notification.get('read', False) else 'unread'}",\n        children=[\n            html.Div(\n                className=f"notification-icon bg-{color}",\n                children=[\n                    html.I(className=f"fas fa-{icon} text-white")\n                ]\n            ),\n            html.Div(\n                className="notification-content",\n                children=[\n                    html.Div(\n                        className="notification-header",\n                        children=[\n                            html.Strong(notification.get("title", "Notification"), className="notification-title"),\n                            html.Small(formatted_date, className="notification-time text-muted")\n                        ]\n                    ),\n                    html.P(notification["message"], className="notification-message mb-0")\n                ]\n            )\n        ]\n    )\n\ndef register_callbacks(app):\n    """Register callbacks for the notification system."""\n    \n    # Check for new notifications from EnhanceX session memory\n    @app.callback(\n        Output("notification-store", "data"),\n        [Input("notification-interval", "n_intervals"),\n         Input({"type": "notification-toast", "index": dash.ALL}, "n_dismiss")],\n        State("notification-store", "data")\n    )\n    def update_notifications(n_intervals, dismissed_toasts, current_data):\n        ctx = callback_context\n        \n        if not current_data:\n            current_data = {"notifications": [], "unread_count": 0}\n        \n        # Get notifications from EnhanceX session memory\n        session_notifications = []\n        try:\n            # Get notifications from session memory\n            interactions = enhancex.get_recent_interactions(interaction_type="notification", limit=10)\n            \n            for interaction in interactions:\n                notification_data = interaction.get("data", {})\n                if notification_data and isinstance(notification_data, dict):\n                    # Check if notification is already in the store\n                    notification_id = notification_data.get("id")\n                    if notification_id:\n                        existing = False\n                        for existing_notification in current_data["notifications"]:\n                            if existing_notification.get("id") == notification_id:\n                                existing = True\n                                break\n                                \n                        if not existing:\n                            session_notifications.append(notification_data)\n        except Exception as e:\n            print(f"Error retrieving notifications from EnhanceX: {e}")\n        \n        # Handle dismissed notifications\n        if ctx.triggered and any(t["prop_id"].startswith('{"type":"notification-toast"') for t in ctx.triggered):\n            for trigger in ctx.triggered:\n                if trigger["prop_id"].startswith('{"type":"notification-toast"'):\n                    try:\n                        # Extract notification ID from the trigger\n                        import json\n                        trigger_id = json.loads(trigger["prop_id"].split(".")[0])\n                        notification_id = trigger_id["index"]\n                        \n                        # Mark notification as read\n                        for notification in current_data["notifications"]:\n                            if notification.get("id") == notification_id and not notification.get("read", False):\n                                notification["read"] = True\n                                current_data["unread_count"] = max(0, current_data["unread_count"] - 1)\n                    except Exception as e:\n                        print(f"Error processing dismissed notification: {e}")\n        \n        # Add new notifications from session memory\n        if session_notifications:\n            current_data["notifications"] = session_notifications + current_data["notifications"]\n            current_data["unread_count"] += len(session_notifications)\n            \n            # Limit the number of stored notifications\n            if len(current_data["notifications"]) > 50:\n                current_data["notifications"] = current_data["notifications"][:50]\n        \n        return current_data\n    \n    # Render active notifications\n    @app.callback(\n        Output("notification-container", "children"),\n        Input("notification-store", "data")\n    )\n    def render_notifications(notification_data):\n        if not notification_data or not notification_data.get("notifications"):\n            return []\n        \n        # Get unread notifications\n        notifications = [\n            notification for notification in notification_data["notifications"]\n            if not notification.get("read", False)\n        ]\n        \n        # Limit to most recent 3 notifications\n        notifications = notifications[:3]\n        \n        return [render_notification(notification) for notification in notifications]\n    \n    # Update notification badge\n    @app.callback(\n        [Output("notification-badge", "children"),\n         Output("notification-badge", "className")],\n        Input("notification-store", "data")\n    )\n    def update_notification_badge(notification_data):\n        if not notification_data:\n            return "", "notification-badge d-none"\n        \n        unread_count = notification_data.get("unread_count", 0)\n        \n        if unread_count > 0:\n            display_count = unread_count if unread_count <= 99 else "99+"\n            return display_count, "notification-badge"\n        else:\n            return "", "notification-badge d-none"\n    \n    # Toggle notification history modal\n    @app.callback(\n        Output("notification-history-modal", "is_open"),\n        [Input("notification-history-button", "n_clicks"),\n         Input("close-notification-history", "n_clicks")],\n        State("notification-history-modal", "is_open")\n    )\n    def toggle_notification_history(n_open, n_close, is_open):\n        ctx = callback_context\n        if not ctx.triggered:\n            return is_open\n        \n        button_id = ctx.triggered[0]["prop_id"].split(".")[0]\n        \n        if button_id == "notification-history-button" and n_open:\n            return True\n        elif button_id == "close-notification-history" and n_close:\n            return False\n        \n        return is_open\n    \n    # Render notification history\n    @app.callback(\n        Output("notification-history-container", "children"),\n        [Input("notification-history-modal", "is_open"),\n         Input("notification-store", "data")]\n    )\n    def render_notification_history(is_open, notification_data):\n        if not is_open or not notification_data or not notification_data.get("notifications"):\n            return []\n        \n        notifications = notification_data["notifications"]\n        \n        if not notifications:\n            return html.P("No notifications", className="text-muted text-center py-4")\n        \n        # Mark all notifications as read when viewing history\n        unread_found = False\n        for notification in notifications:\n            if not notification.get("read", False):\n                notification["read"] = True\n                unread_found = True\n        \n        if unread_found:\n            # Update unread count in EnhanceX session memory\n            notification_data["unread_count"] = 0\n        \n        return [render_notification_history_item(notification) for notification in notifications]\n\n# Function to add a notification via EnhanceX\ndef add_notification(notification_type, message, title=None, duration=DEFAULT_DURATION):\n    """\n    Add a notification to the system via EnhanceX session memory.\n    \n    Args:\n        notification_type (str): Type of notification (info, success, warning, error)\n        message (str): Notification message\n        title (str, optional): Notification title\n        duration (int, optional): Duration in milliseconds\n    """\n    notification = create_notification(notification_type, message, title, duration)\n    \n    # Store notification in EnhanceX session memory\n    enhancex.record_interaction(\n        interaction_type="notification",\n        data=notification\n    )\n    \n    return notification